TCP/IP网络编程读书笔记 尹圣雨著（仅Linux部分）

> 测试环境：腾讯云服务器
>
> 1核 2GB 1Mbps
>
> 系统盘：高性能云硬盘
>
> 网络：Default-VPC
>
> 系统：Ubuntu18.04

# 第一章 理解网络编程和套接字

## 1.1 编写”hello world“服务端

- 调用socket函数创建套接字，该套接字并非真正的服务器端套接字

- 调用bind函数分配IP地址和端口号
- 调用listen函数将套接字转为可接收连接状态，连接请求等待队列的长度设置为5，此时的套接字才是服务器端套接字
- 调用accept函数受理连接请求。从队头取一个连接请求与客户端建立连接，并返回创建的套接字文件描述符。另外，调用accept函数时若等待队列为空，则accept函数不会返回，直到队列中出现新的客户端连接。
- write函数向客户端传输数据，调用close函数关闭连接



## 1.2 编写“hello world“客户端

- 调用socket函数创建套接字
- 调用connect函数向服务器端发送连接请求



# 第二章 套接字类型与协议设置

## 2.1 创建套接字

![1588508600367](1588508600367.png)

协议族中PF_INET对应IPv4互联网协议族

## 2.2 套接字类型

### 类型1：面向连接的套接字（SOCK_STREAM）

如果socket函数的第二个参数传递SOCK_STREAM，将创建面向连接的套接字，其特征如下

- 传输过程中数据不会消失
- 按序传输数据
- 传输的数据不存在数据边界

***不存在数据边界：收到数据并不意味着马上调用read函数，只要不超过收数据的套接字的缓冲区容量，则有可能在数据填充缓冲后通过一次read函数调用读取全部，也有可能分多次read函数调用读取。***

### 类型2：面向消息的套接字（SOCK_DGRAM）

如果socket函数的第二个参数传递SOCK_DGRAM，将创建面向消息的套接字，其特征如下

- 强调快速传输而非传输顺序
- 传输的数据可能丢失也可能损毁
- 传输的数据有数据边界
- 限制每次传输的数据大小

***存在数据边界：发送者发几次数据，接收者就要分几次接收***



## 2.3 协议的最终选择

socket函数的第三个参数，大部分情况为0，但除非遇到以下情况：“同一协议族中存在多个数据传输方式相同的协议”，即传输方式相同，但协议不同。

如“IPv4协议族中面向连接的套接字”

```c
int tcp_socket = socket(PF_INET, SOCK_STRAM, IPPROTO_TCP);
```

如"IPv4协议族中面向消息的套接字"

```c
int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
```

## 2.4 面向连接的套接字：TCP套接字示例

验证“传输的数据不存在数据边界”，从运行结果可以看出，服务器端发送13字节的数据，客户端调用了13次read函数进行读取。

![1588511511111](1588511511111.png)





# 第四章 基于TCP的服务器端/客户端（1）

## 4.1 TCP服务端

### 进入等待连接请求状态

![1588512197294](1588512197294.png)

***listen函数的第二个参数值backlog与服务器端的特性有关，像频繁接收请求的Web服务器端至少为15。***


### 受理客户端连接请求

![1588512622152](1588512622152.png)

accept函数受理连接请求队列中待处理的客户端连接请求。函数调用成功时，accept函数内部将产生用于数据I/O的套接字，并返回其文件描述符。

套接字是自动创建的，并自动与发起连接请求的客户端建立连接。



## 4.2 TCP客户端

与服务端相比，区别在于“请求连接”，它是创建客户端套接字后向服务器端发起的连接请求。服务器端调用listen函数后创建连接请求等待队列，之后客户端即可请求连接
![1588523983073](1588523983073.png)

接收请求并不意味着调用accept函数，而是把请求放到等待队列中。

**客户端调用connect后，发生以下情况之一才会返回：**

- 服务器端接收连接请求
- 发生断网异常

***客户端的套接字中IP地址和端口是由操作系统内核调用connect函数时调用的，IP用的是主机的IP，端口是随机分配***



![1588524295772](1588524295772.png)

# 第五章 基于TCP的服务器端/客户端（2）

## 5.1 回显服务器端/客户端

### 回显客户端存在的问题

在原先版本的echo_client.c中，错误的假设了每次调用write、read函数时都会以字符串为单位执行实际的I/O操作，即每次调用write、函数都会传递1个字符串。**但多次调用write函数传递的字符串有可能一次性传递到服务器端。此时客户端有可能从服务器端收到多个字符串，这不是我们希望看到的结果。还需考虑服务器端因为字符串太长，分两个数据包发送的情况。**



### 回显客户端的改进

**回显客户端传输的是字符串，而且是通过调用write函数一次性发送的，发完后再调用read等待接收自己发出去由服务端传回的字符串。**但read是否能一次性读取所有字符串数据呢？

解决方法：因为echo客户端发送时就已知了要接收回来的字符串大小，在接收时循环接收该大小的字节数即可。

```c
while(recv_len < str_len)
{
    //...
}
```



## 5.2 定义应用层协议

echo客户端可以提前知道接收的字符串大小，但其他场景下这不太可能，所以要设计应用层协议。



## 5.3 TCP原理

### TCP套接字中的I/O缓冲

实际上，write函数调用后并非立即传输数据，read函数调用后也并非马上接收数据。更准确地说，write函数调用瞬间，数据将移至输出缓冲；read函数调用瞬间，从输入缓冲读取数据。