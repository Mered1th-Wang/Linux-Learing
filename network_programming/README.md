TCP/IP网络编程读书笔记 尹圣雨著（仅Linux部分）

> 测试环境：腾讯云服务器
>
> 1核 2GB 1Mbps
>
> 系统盘：高性能云硬盘
>
> 网络：Default-VPC
>
> 系统：Ubuntu18.04

有部分内容在Linux系统编程中已经总结过笔记，就不再赘述了。

# 第一章 理解网络编程和套接字

## 1.1 编写”hello world“服务端

- 调用socket函数创建套接字，该套接字并非真正的服务器端套接字

- 调用bind函数分配IP地址和端口号
- 调用listen函数将套接字转为可接收连接状态，连接请求等待队列的长度设置为5，此时的套接字才是服务器端套接字
- 调用accept函数受理连接请求。从队头取一个连接请求与客户端建立连接，并返回创建的套接字文件描述符。另外，调用accept函数时若等待队列为空，则accept函数不会返回，直到队列中出现新的客户端连接。
- write函数向客户端传输数据，调用close函数关闭连接



## 1.2 编写“hello world“客户端

- 调用socket函数创建套接字
- 调用connect函数向服务器端发送连接请求



# 第二章 套接字类型与协议设置

## 2.1 创建套接字

![1588508600367](assets/1588508600367.png)

协议族中PF_INET对应IPv4互联网协议族

## 2.2 套接字类型

### 类型1：面向连接的套接字（SOCK_STREAM）

如果socket函数的第二个参数传递SOCK_STREAM，将创建面向连接的套接字，其特征如下

- 传输过程中数据不会消失
- 按序传输数据
- 传输的数据不存在数据边界

***不存在数据边界：收到数据并不意味着马上调用read函数，只要不超过收数据的套接字的缓冲区容量，则有可能在数据填充缓冲后通过一次read函数调用读取全部，也有可能分多次read函数调用读取。***

### 类型2：面向消息的套接字（SOCK_DGRAM）

如果socket函数的第二个参数传递SOCK_DGRAM，将创建面向消息的套接字，其特征如下

- 强调快速传输而非传输顺序
- 传输的数据可能丢失也可能损毁
- 传输的数据有数据边界
- 限制每次传输的数据大小

***存在数据边界：发送者发几次数据，接收者就要分几次接收***



## 2.3 协议的最终选择

socket函数的第三个参数，大部分情况为0，但除非遇到以下情况：“同一协议族中存在多个数据传输方式相同的协议”，即传输方式相同，但协议不同。

如“IPv4协议族中面向连接的套接字”

```c
int tcp_socket = socket(PF_INET, SOCK_STRAM, IPPROTO_TCP);
```

如"IPv4协议族中面向消息的套接字"

```c
int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
```

## 2.4 面向连接的套接字：TCP套接字示例

验证“传输的数据不存在数据边界”，从运行结果可以看出，服务器端发送13字节的数据，客户端调用了13次read函数进行读取。

![1588511511111](assets/1588511511111.png)



# 第四章 基于TCP的服务器端/客户端（1）

## 4.1 TCP服务端

### 进入等待连接请求状态

![1588512197294](assets/1588512197294.png)

***listen函数的第二个参数值backlog与服务器端的特性有关，像频繁接收请求的Web服务器端至少为15。***


### 受理客户端连接请求

![1588512622152](assets/1588512622152.png)

accept函数受理连接请求队列中待处理的客户端连接请求。函数调用成功时，accept函数内部将产生用于数据I/O的套接字，并返回其文件描述符。

套接字是自动创建的，并自动与发起连接请求的客户端建立连接。



## 4.2 TCP客户端

与服务端相比，区别在于“请求连接”，它是创建客户端套接字后向服务器端发起的连接请求。服务器端调用listen函数后创建连接请求等待队列，之后客户端即可请求连接
![1588523983073](assets/1588523983073.png)

接收请求并不意味着调用accept函数，而是把请求放到等待队列中。

**客户端调用connect后，发生以下情况之一才会返回：**

- 服务器端接收连接请求
- 发生断网异常

***客户端的套接字中IP地址和端口是由操作系统内核调用connect函数时调用的，IP用的是主机的IP，端口是随机分配***



![1588524295772](assets/1588524295772.png)

# 第五章 基于TCP的服务器端/客户端（2）

## 5.1 回显服务器端/客户端

### 回显客户端存在的问题

在原先版本的echo_client.c中，错误的假设了每次调用write、read函数时都会以字符串为单位执行实际的I/O操作，即每次调用write、函数都会传递1个字符串。**但多次调用write函数传递的字符串有可能一次性传递到服务器端。此时客户端有可能从服务器端收到多个字符串，这不是我们希望看到的结果。还需考虑服务器端因为字符串太长，分两个数据包发送的情况。**



### 回显客户端的改进

**回显客户端传输的是字符串，而且是通过调用write函数一次性发送的，发完后再调用read等待接收自己发出去由服务端传回的字符串。**但read是否能一次性读取所有字符串数据呢？

解决方法：因为echo客户端发送时就已知了要接收回来的字符串大小，在接收时循环接收该大小的字节数即可。

```c
while(recv_len < str_len)
{
    //...
}
```



## 5.2 定义应用层协议

echo客户端可以提前知道接收的字符串大小，但其他场景下这不太可能，所以要设计应用层协议。



## 5.3 TCP原理

### TCP套接字中的I/O缓冲

TCP套接字的数据收发无边界，服务器端即时使用一次write函数传输40B的数据，客户端也可能通过4次read函数调用每次读取10B。

实际上，write函数调用后并非立即传输数据，read函数调用后也并非马上接收数据。更准确地说，write函数调用瞬间，数据将移至输出缓冲；read函数调用瞬间，从输入缓冲读取数据。

**I/O缓冲的特征**

- I/O缓冲在每个TCP套接字中单独存在
- I/O缓冲在创建套接字时自动生成
- 即时关闭套接字也会继续传递输出缓冲中遗留的数据
- 关闭套接字将丢失输入缓冲中的数据

# 第六章 基于UDP的服务器端/客户端

流控制是区分UDP和TCP的最重要的标志。

UDP中的服务器端和客户端没有连接，且UDP服务器端和客户端均只需1个套接字。**TCP中，套接字之间是一对一的关系，若要向10个客户端提供服务，则除了守门的服务器套接字外，还需要10个服务器端套接字。但UDP中，不管是服务器端还是客户端只需1个套**接字。

## 6.1 基于UDP的数据I/O函数

![1588567843859](C:/Users/Mered1th/AppData/Roaming/Typora/typora-user-images/1588567843859.png)

调用sendto函数时自动分配IP（本地主机的IP）和端口号（未使用的端口号随机），因此UDP无需额外的地址分配过程

![1588567858934](C:/Users/Mered1th/AppData/Roaming/Typora/typora-user-images/1588567858934.png)

## 6.2 存在数据边界的UDP套接字
UDP是具有数据边界的协议，**输入函数的调用次数应和输出函数的调用次数完全一致**。



# 第七章 断开套接字连接

## 7.1 基于TCP的半关闭

### shutdown函数

针对半关闭，shutdown函数用来关闭其中一个流

![1588571699374](assets/1588571699374.png)

- 第二个参数决定断开的方式
  - SHUT_RD：断开输入流，套接字无法再接收数据
  - SHUT_WR：断开输出流，套接字无法再传输数据
  - SHUT_RDWR：同时断开I/O流



# 第九章 套接字的多种可选项和I/O缓冲大小

![1588574590644](assets/1588574590644.png)

![1588574600829](assets/1588574600829.png)

## 9.1 SO_SNDBUF & SO_RCVBUF

创建套接字将同时生成I/O缓冲

SO_RCVBUF是输入缓冲大小相关可选项，SO_SNDBUF是输出缓冲大小相关可选项。

## 9.2 TIME_WAIT状态
在控制台输入CTRL+C后，套接字经过四次挥手过程后并非立即消除，而是要经过一段时间的TIME_WAIT状态。当然，只有先断开连接（先发送FIN消息的）主机才经过TIME_WAIT状态，因此服务器端CTRL+C后，套接字会处于该状态，bind()无法立即使用。

而客户端套接字的端口是任意指定的，所以无需关注TIME_WAIT状态。

解决方案：在套接字的可选项中更改SO_REUSEADDR的状态，默认是0，修改为1即可。

## 9.3 TCP_NODELAY
### Nagle算法
作用：为了防止因数据包过多而发生网络过载，它应用于TCP层。

![1588576616274](assets/1588576616274.png)

不适用于大文件传输，禁用方法：

![1588576846645](assets/1588576846645.png)

# 第十章 多进程服务器端

## 通过fork函数复制文件描述符

通过fork函数，父进程会将套接字文件描述符复制给子进程，此时2个文件描述符将指向同一个套接字。

![1588582081569](assets/1588582081569.png)

在调用fork函数后，要将无关的套接字文件描述符关闭，其原因类似引用计数，只有在所有文件描述符都终止时才能销毁套接字，以免造成不必要的文件描述符占用。



# 第十三章 多种I/O函数

## 13.1 send&recv函数

![1588590667395](assets/1588590667395.png)

![1588590680582](assets/1588590680582.png)

send和recv函数的最后一个参数是收发数据时的可选项。![1588590726240](assets/1588590726240.png)

MSG_PEEK选项，可以保证即时不存在待读取数据也不会进入阻塞状态。若不设置该选项，在本次读取的数据后将从输入缓冲区中将数据删除。



## 13.2 readv & writev函数

对数据进行整合传输及发送的函数。

也就是说，通过writev函数可以将分散保存在多个缓冲中的数据一并发送，通过readv函数可以由多个缓冲分别接收。因此，适当使用这两个函数可以减少I/O函数调用的次数。

![1588594520897](assets/1588594520897.png)

![1588594526790](assets/1588594526790.png)

```c
struct iovec
{
    void * iov_base;	//缓冲地址
    size_t iov_len;		//缓冲大小
}
```

![1588594567532](assets/1588594567532.png)

如上图，writev的第一个参数1是文件描述符，因此向控制台输出数据。

**ptr是存有待发送数据信息的iovec数组指针**。第三个参数2表示共浏览2个iovec结构体变量。



适用范围：要传输的数据位于不同缓冲（数组）时；当关闭Nagle算法时使用；